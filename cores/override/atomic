namespace std
{
    typedef enum memory_order {
        memory_order_relaxed,
        memory_order_consume,
        memory_order_acquire,
        memory_order_release,
        memory_order_acq_rel,
        memory_order_seq_cst 
    } memory_order;

    template <typename T>
    struct atomic
    {
    public:
        atomic() {}
        atomic(T new_value) { this->value = new_value; }

        bool load(memory_order sync) volatile { return this->value; }

        T exchange(T new_value) 
        {
            T old_value = this->value;
            this->value = new_value; 
            return old_value;
        }

        operator T() { return this->value; }

        T value;
    };

    template<typename T>
    T atomic_fetch_add_explicit(volatile atomic<T>* obj, T val, memory_order sync) 
    {
        T old = obj->load(sync);
        obj->value = old + val;
        return old;
    }

    template<typename T>
    T atomic_fetch_or_explicit(volatile atomic<T>* obj, T val, memory_order sync)
    {
        T old = obj->load(sync);
        obj->value = old | val;
        return old;
    }

    template<typename T>
    T atomic_fetch_and_explicit(volatile atomic<T>* obj, T val, memory_order sync)
    {
        T old = obj->load(sync);
        obj->value = old & val;
        return old;
    }

    template<typename T>
    T atomic_fetch_xor_explicit(volatile atomic<T>* obj, T val, memory_order sync)
    {
        T old = obj->load(sync);
        obj->value = old ^ val;
        return old;
    }

    typedef atomic<bool> atomic_bool;
}
